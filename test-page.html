<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Website Analytics Dashboard - Test Data</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .data-section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .hidden {
            display: none;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            padding: 8px 12px;
            text-align: left;
            border: 1px solid #ddd;
        }
        th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
        .instruction {
            background-color: #e3f2fd;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #2196f3;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Website Analytics Dashboard</h1>
        <p>Sample data for SankeyStone extension testing</p>
    </div>

    <div class="instruction">
        <strong>Instructions:</strong> Load the SankeyStone Chrome extension and click the extension icon while viewing this page. 
        The extension should automatically detect and visualize the traffic flow data below.
    </div>

    <div class="data-section">
        <h3>ðŸ§ª Test Controls</h3>
        <p>Use this button to test the extension with different business contexts:</p>
        <button id="randomize-data" style="background-color: #2196f3; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">ðŸŽ² Generate New Context & Data</button>
        <p style="margin-top: 10px; font-size: 14px; color: #666;">This will generate a completely new business scenario with different labels and values. Use "Refresh from Page" in the SankeyStone extension to visualize the new data.</p>
        <div id="current-context" style="margin-top: 15px; padding: 10px; background: #f5f5f5; border-radius: 4px; font-style: italic;">Current Context: Website Analytics</div>
    </div>

    <!-- Sankey Data embedded in the page -->
    <div class="data-section">
        <h2>Traffic Flow Data</h2>
        <p>The data below represents website traffic flow from sources to pages to outcomes.</p>
        
        <!-- Data in JSON format for easy extraction -->
        <script type="application/json" id="sankey-data">
        {
            "nodes": [
                { "id": 0, "name": "Google Search", "layer": 0, "category": "traffic_source" },
                { "id": 1, "name": "Facebook", "layer": 0, "category": "traffic_source" },
                { "id": 2, "name": "Twitter", "layer": 0, "category": "traffic_source" },
                { "id": 3, "name": "Direct Traffic", "layer": 0, "category": "traffic_source" },
                { "id": 4, "name": "Homepage", "layer": 1, "category": "page" },
                { "id": 5, "name": "Product Catalog", "layer": 1, "category": "page" },
                { "id": 6, "name": "Blog", "layer": 1, "category": "page" },
                { "id": 7, "name": "Contact Page", "layer": 1, "category": "page" },
                { "id": 8, "name": "Purchase", "layer": 2, "category": "outcome" },
                { "id": 9, "name": "Newsletter Signup", "layer": 2, "category": "outcome" },
                { "id": 10, "name": "Bounce", "layer": 2, "category": "outcome" }
            ],
            "links": [
                { "source": 0, "target": 4, "value": 3200 },
                { "source": 0, "target": 5, "value": 2800 },
                { "source": 0, "target": 6, "value": 1500 },
                { "source": 1, "target": 4, "value": 1800 },
                { "source": 1, "target": 6, "value": 1200 },
                { "source": 2, "target": 4, "value": 900 },
                { "source": 2, "target": 6, "value": 1100 },
                { "source": 3, "target": 4, "value": 2200 },
                { "source": 3, "target": 5, "value": 1600 },
                { "source": 3, "target": 7, "value": 400 },
                { "source": 4, "target": 8, "value": 1200 },
                { "source": 4, "target": 9, "value": 800 },
                { "source": 4, "target": 10, "value": 6100 },
                { "source": 5, "target": 8, "value": 1800 },
                { "source": 5, "target": 9, "value": 400 },
                { "source": 5, "target": 10, "value": 3200 },
                { "source": 6, "target": 9, "value": 1200 },
                { "source": 6, "target": 10, "value": 2600 },
                { "source": 7, "target": 9, "value": 150 },
                { "source": 7, "target": 10, "value": 250 },
                { "source": 0, "target": 8, "value": 600 },
                { "source": 1, "target": 10, "value": 420 },
                { "source": 3, "target": 9, "value": 350 },
                { "source": 2, "target": 8, "value": 280 },
                { "source": 1, "target": 8, "value": 320 },
                { "source": 0, "target": 10, "value": 890 },
                { "source": 2, "target": 9, "value": 180 },
                { "source": 3, "target": 8, "value": 450 }
            ]
        }
        </script>
    </div>

    <!-- Alternative: Data in HTML table format -->
    <div class="data-section">
        <h3>Traffic Sources</h3>
        <table class="traffic-sources" data-sankey-layer="0">
            <thead>
                <tr>
                    <th>Source</th>
                    <th>Visitors</th>
                </tr>
            </thead>
            <tbody>
                <tr data-node-id="0">
                    <td>Google Search</td>
                    <td>7,500</td>
                </tr>
                <tr data-node-id="1">
                    <td>Facebook</td>
                    <td>3,000</td>
                </tr>
                <tr data-node-id="2">
                    <td>Twitter</td>
                    <td>2,000</td>
                </tr>
                <tr data-node-id="3">
                    <td>Direct Traffic</td>
                    <td>4,200</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="data-section">
        <h3>Page Destinations</h3>
        <table class="page-destinations" data-sankey-layer="1">
            <thead>
                <tr>
                    <th>Page</th>
                    <th>Visitors</th>
                </tr>
            </thead>
            <tbody>
                <tr data-node-id="4">
                    <td>Homepage</td>
                    <td>8,100</td>
                </tr>
                <tr data-node-id="5">
                    <td>Product Catalog</td>
                    <td>5,400</td>
                </tr>
                <tr data-node-id="6">
                    <td>Blog</td>
                    <td>3,800</td>
                </tr>
                <tr data-node-id="7">
                    <td>Contact Page</td>
                    <td>400</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="data-section">
        <h3>Final Outcomes</h3>
        <table class="outcomes" data-sankey-layer="2">
            <thead>
                <tr>
                    <th>Outcome</th>
                    <th>Count</th>
                </tr>
            </thead>
            <tbody>
                <tr data-node-id="8">
                    <td>Purchase</td>
                    <td>3,000</td>
                </tr>
                <tr data-node-id="9">
                    <td>Newsletter Signup</td>
                    <td>2,550</td>
                </tr>
                <tr data-node-id="10">
                    <td>Bounce</td>
                    <td>12,150</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="data-section">
        <h3>How to Use SankeyStone</h3>
        <ol>
            <li>Install the SankeyStone Chrome extension</li>
            <li>Visit this page (or any page with similar data structure)</li>
            <li>Click the SankeyStone extension icon</li>
            <li>View the automatically generated Sankey diagram</li>
            <li>Use "Regenerate" to refresh with current page data</li>
        </ol>
    </div>
    <!-- JavaScript for data manipulation -->
    <script>
        // Different business contexts with expandable label pools
        const businessContexts = {
            'ecommerce': {
                name: 'E-commerce Analytics',
                labelPools: [
                    ['Google Ads', 'Facebook Ads', 'Email Campaign', 'Organic Search', 'Affiliate Links', 'Instagram Ads'],
                    ['Product Pages', 'Category Pages', 'Search Results', 'Cart Page', 'Checkout', 'Reviews'],
                    ['Add to Cart', 'Wishlist', 'Compare', 'Share', 'Quick View', 'Size Guide'],
                    ['Purchase', 'Abandoned Cart', 'Guest Checkout', 'Account Created', 'Newsletter', 'Exit']
                ]
            },
            'education': {
                name: 'Online Education Platform',
                labelPools: [
                    ['Course Catalog', 'Social Media', 'Partner Sites', 'Direct Access', 'Search Engine', 'Referrals'],
                    ['Course Preview', 'Instructor Profile', 'Pricing Page', 'Free Content', 'Student Reviews', 'Curriculum'],
                    ['Watch Demo', 'Download Syllabus', 'Chat with Advisor', 'Read Reviews', 'Compare Courses', 'FAQ'],
                    ['Enrollment', 'Free Trial', 'Contact', 'Bookmark', 'Share Course', 'Exit']
                ]
            },
            'healthcare': {
                name: 'Healthcare Patient Flow',
                labelPools: [
                    ['Emergency', 'Referral', 'Walk-in', 'Appointment', 'Telemedicine', 'Insurance Portal'],
                    ['Triage', 'Consultation', 'Diagnostics', 'Waiting Room', 'Specialist', 'Lab Tests'],
                    ['X-Ray', 'Blood Work', 'Physical Exam', 'Medical History', 'Vital Signs', 'Screening'],
                    ['Treatment', 'Prescription', 'Follow-up', 'Discharge', 'Referral Out', 'Home Care']
                ]
            },
            'saas': {
                name: 'SaaS Product Analytics',
                labelPools: [
                    ['Trial Signup', 'Demo Request', 'Pricing Page', 'Blog Content', 'Webinar', 'Free Tools'],
                    ['Dashboard', 'Feature Tour', 'Documentation', 'Settings', 'Onboarding', 'Templates'],
                    ['Create Project', 'Import Data', 'Invite Team', 'Watch Tutorial', 'Contact Support', 'Upgrade Prompt'],
                    ['Subscription', 'Free Plan', 'Support Ticket', 'Churn', 'Referral', 'Feature Request']
                ]
            },
            'media': {
                name: 'Content Platform Analytics',
                labelPools: [
                    ['Homepage', 'Search', 'Recommendations', 'Social Shares', 'Direct Link', 'Push Notification'],
                    ['Article View', 'Video Play', 'Gallery Browse', 'Profile Visit', 'Category Page', 'Trending'],
                    ['Like', 'Share', 'Bookmark', 'Comment', 'Follow Author', 'Related Content'],
                    ['Subscribe', 'Share External', 'Comment Posted', 'Bounce', 'Download', 'Print']
                ]
            },
            'finance': {
                name: 'Financial Services Flow',
                labelPools: [
                    ['Web Search', 'Mobile App', 'Branch Visit', 'Phone Call', 'Email Link', 'Advertisement'],
                    ['Account Info', 'Loan Calculator', 'Investment Tools', 'Support', 'Product Comparison', 'Rates Page'],
                    ['Apply Online', 'Schedule Meeting', 'Download Forms', 'Chat Support', 'Call Back Request', 'Email Info'],
                    ['Account Opening', 'Loan Application', 'Investment', 'Information Only', 'Referral', 'Follow-up Call']
                ]
            },
            'manufacturing': {
                name: 'Manufacturing Process Flow',
                labelPools: [
                    ['Raw Materials', 'Supplier A', 'Supplier B', 'Recycled Input', 'Emergency Stock'],
                    ['Quality Check', 'Assembly Line 1', 'Assembly Line 2', 'Custom Orders', 'Batch Processing'],
                    ['Testing', 'Packaging', 'Quality Assurance', 'Labeling', 'Inventory'],
                    ['Shipped', 'Warehoused', 'Rejected', 'Rework', 'Customer Direct']
                ]
            },
            'retail': {
                name: 'Retail Customer Journey',
                labelPools: [
                    ['Store Entry', 'Online Browse', 'Mobile App', 'Social Media', 'Email Campaign', 'Friend Referral'],
                    ['Browse Products', 'Ask Staff', 'Try On', 'Check Price', 'Compare Options', 'Read Reviews'],
                    ['Consider Purchase', 'Add to Cart', 'Ask Questions', 'Check Stock', 'Request Help', 'Take Photo'],
                    ['Purchase', 'Save for Later', 'Leave Store', 'Sign up Newsletter', 'Return Item', 'Recommend Friend'],
                    ['Follow-up Survey', 'Loyalty Program', 'Return Visit', 'Online Review', 'Social Share']
                ]
            }
        };
        
        // Current context
        let currentContext = 'ecommerce';
        
        // Function to generate random number between min and max
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // Function to format number with commas
        function formatNumber(num) {
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }
        
        // Function to pick random item from array
        function randomChoice(array) {
            return array[Math.floor(Math.random() * array.length)];
        }
        
        // Function to shuffle and select random items from array
        function selectRandom(array, count) {
            const shuffled = [...array].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }
        
        // Function to generate completely new context and data with variable layers and nodes
        function generateNewContextData() {
            // Pick a random business context
            const contextKeys = Object.keys(businessContexts);
            currentContext = randomChoice(contextKeys);
            const contextTemplate = businessContexts[currentContext];
            
            // Determine number of layers (2-5)
            const numLayers = randomInt(2, Math.min(5, contextTemplate.labelPools.length));
            
            // Build the actual context with variable layers and nodes
            const context = {
                name: contextTemplate.name,
                layers: []
            };
            
            // For each layer, select random number of nodes (2-6)
            for (let layerIndex = 0; layerIndex < numLayers; layerIndex++) {
                const maxNodes = Math.min(6, contextTemplate.labelPools[layerIndex].length);
                const numNodes = randomInt(2, maxNodes);
                const selectedLabels = selectRandom(contextTemplate.labelPools[layerIndex], numNodes);
                context.layers.push(selectedLabels);
            }
            
            console.log(`Generated new context: ${context.name} with ${numLayers} layers`, context.layers);
            
            // Update context display with layer info
            const layerInfo = context.layers.map((layer, i) => `Layer ${i + 1}: ${layer.length} nodes`).join(', ');
            document.getElementById('current-context').textContent = `Current Context: ${context.name} (${layerInfo})`;
            
            // Update page title and description
            document.querySelector('.header h1').textContent = context.name;
            document.querySelector('.header p').textContent = `Sample data for SankeyStone extension testing - ${context.name.toLowerCase()} with ${numLayers} layers`;
            
            // Generate new data structure
            const nodes = [];
            const links = [];
            let nodeIdCounter = 0;
            
            // Create nodes for each layer
            const layerStartIds = [];
            for (let layerIndex = 0; layerIndex < context.layers.length; layerIndex++) {
                layerStartIds.push(nodeIdCounter);
                context.layers[layerIndex].forEach((name, nodeIndex) => {
                    nodes.push({ 
                        id: nodeIdCounter++, 
                        name: name, 
                        layer: layerIndex, 
                        category: layerIndex === 0 ? "source" : 
                                 layerIndex === context.layers.length - 1 ? "outcome" : "middle"
                    });
                });
            }
            
            // Generate random links between layers (including layer-skipping and convergent flows)
            for (let layerIndex = 0; layerIndex < context.layers.length - 1; layerIndex++) {
                const currentLayerStart = layerStartIds[layerIndex];
                const currentLayerSize = context.layers[layerIndex].length;
                const nextLayerStart = layerStartIds[layerIndex + 1];
                const nextLayerSize = context.layers[layerIndex + 1].length;
                
                // Strategy 1: Standard connections - each node connects to some nodes in next layer
                for (let sourceIndex = 0; sourceIndex < currentLayerSize; sourceIndex++) {
                    const sourceId = currentLayerStart + sourceIndex;
                    
                    // Connect to 1-3 nodes in the next layer
                    const numConnections = randomInt(1, Math.min(3, nextLayerSize));
                    const targetIndices = selectRandom([...Array(nextLayerSize).keys()], numConnections);
                    
                    targetIndices.forEach(targetIndex => {
                        const targetId = nextLayerStart + targetIndex;
                        links.push({
                            source: sourceId,
                            target: targetId,
                            value: randomInt(100, 3000)
                        });
                    });
                }
                
                // Strategy 2: Create convergent flows - multiple sources merge into popular targets
                if (Math.random() < 0.8) { // 80% chance to add convergent flows
                    // Pick 1-2 "popular" target nodes that will receive convergent flows
                    const convergentTargetCount = Math.min(2, nextLayerSize);
                    const convergentTargets = selectRandom([...Array(nextLayerSize).keys()], convergentTargetCount);
                    
                    convergentTargets.forEach(targetIndex => {
                        const targetId = nextLayerStart + targetIndex;
                        
                        // Have 2-4 additional sources connect to this popular target
                        const additionalSourceCount = Math.min(randomInt(2, 4), currentLayerSize);
                        const additionalSources = selectRandom([...Array(currentLayerSize).keys()], additionalSourceCount);
                        
                        additionalSources.forEach(sourceIndex => {
                            const sourceId = currentLayerStart + sourceIndex;
                            
                            // Add convergent link with moderate values
                            links.push({
                                source: sourceId,
                                target: targetId,
                                value: randomInt(150, 1200)
                            });
                            console.log(`Added convergent flow from node ${sourceId} to popular target ${targetId}`);
                        });
                    });
                }
                
                // Strategy 3: Add layer-skipping links (for nodes that are at least 2 layers apart)
                if (layerIndex < context.layers.length - 2 && Math.random() < 0.7) { // 70% chance to add skipping links
                    // Determine how many layers to skip
                    const maxSkip = Math.min(3, context.layers.length - layerIndex - 1); // Skip at most 3 layers
                    const layersToSkip = randomInt(1, maxSkip);
                    const targetLayerIndex = layerIndex + 1 + layersToSkip;
                    
                    if (targetLayerIndex < context.layers.length) {
                        const skipLayerStart = layerStartIds[targetLayerIndex];
                        const skipLayerSize = context.layers[targetLayerIndex].length;
                        
                        // Pick 1-2 source nodes from current layer
                        const skipSourceCount = Math.min(2, currentLayerSize);
                        const skipSourceIndices = selectRandom([...Array(currentLayerSize).keys()], skipSourceCount);
                        
                        skipSourceIndices.forEach(sourceIndex => {
                            const sourceId = currentLayerStart + sourceIndex;
                            
                            // Connect to 1-2 nodes in the target layer
                            const skipTargetCount = Math.min(2, skipLayerSize);
                            const skipTargetIndices = selectRandom([...Array(skipLayerSize).keys()], skipTargetCount);
                            
                            skipTargetIndices.forEach(targetIndex => {
                                const skipTargetId = skipLayerStart + targetIndex;
                                links.push({
                                    source: sourceId,
                                    target: skipTargetId,
                                    value: randomInt(50, 800) // Smaller values for skipping links
                                });
                                console.log(`Added skipping link from layer ${layerIndex} to layer ${targetLayerIndex}`);
                            });
                        });
                    }
                }
                
                // Strategy 4: Cross-layer convergent flows - multiple layers converging to final outcomes
                if (layerIndex === 0 && context.layers.length >= 3 && Math.random() < 0.6) { // 60% chance for first layer to have cross-layer convergence
                    const finalLayerIndex = context.layers.length - 1;
                    const finalLayerStart = layerStartIds[finalLayerIndex];
                    const finalLayerSize = context.layers[finalLayerIndex].length;
                    
                    // Pick 1-2 "major outcome" nodes in the final layer
                    const majorOutcomeCount = Math.min(2, finalLayerSize);
                    const majorOutcomes = selectRandom([...Array(finalLayerSize).keys()], majorOutcomeCount);
                    
                    majorOutcomes.forEach(outcomeIndex => {
                        const outcomeId = finalLayerStart + outcomeIndex;
                        
                        // Have 1-3 sources from this layer connect directly to the major outcome
                        const directSourceCount = Math.min(randomInt(1, 3), currentLayerSize);
                        const directSources = selectRandom([...Array(currentLayerSize).keys()], directSourceCount);
                        
                        directSources.forEach(sourceIndex => {
                            const sourceId = currentLayerStart + sourceIndex;
                            links.push({
                                source: sourceId,
                                target: outcomeId,
                                value: randomInt(80, 600) // Medium values for direct-to-outcome flows
                            });
                            console.log(`Added cross-layer convergent flow from source ${sourceId} to outcome ${outcomeId}`);
                        });
                    });
                }
            }
            
            return { nodes, links, context, numLayers };
        }
        
        // Function to update JSON data with new context
        function updateJsonData(data) {
            const dataElement = document.getElementById('sankey-data');
            if (dataElement) {
                dataElement.textContent = JSON.stringify(data, null, 4);
            }
        }
        
        // Function to dynamically create/update HTML tables with new variable layer structure
        function updateTableData(data, context) {
            // Remove existing table sections (except the first one which we'll keep for reference)
            const existingTables = document.querySelectorAll('.data-section');
            existingTables.forEach((section, index) => {
                if (section.querySelector('table[data-sankey-layer]')) {
                    section.remove();
                }
            });
            
            // Find the JSON data section to insert tables after it
            const jsonSection = document.querySelector('#sankey-data').parentNode;
            
            // Create tables for each layer
            context.layers.forEach((layerNodes, layerIndex) => {
                const layerName = layerIndex === 0 ? 'Sources' : 
                                layerIndex === context.layers.length - 1 ? 'Outcomes' : 
                                `Layer ${layerIndex + 1}`;
                
                // Create table section
                const tableSection = document.createElement('div');
                tableSection.className = 'data-section';
                
                const heading = document.createElement('h3');
                heading.textContent = `${layerName}`;
                tableSection.appendChild(heading);
                
                // Create table
                const table = document.createElement('table');
                table.className = layerIndex === 0 ? 'traffic-sources' : 
                                 layerIndex === context.layers.length - 1 ? 'outcomes' : 
                                 `layer-${layerIndex}`;
                table.setAttribute('data-sankey-layer', layerIndex);
                
                // Create table header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const nameHeader = document.createElement('th');
                nameHeader.textContent = layerIndex === 0 ? 'Source' : 
                                       layerIndex === context.layers.length - 1 ? 'Outcome' : 
                                       'Item';
                const countHeader = document.createElement('th');
                countHeader.textContent = layerIndex === 0 ? 'Visitors' : 'Count';
                headerRow.appendChild(nameHeader);
                headerRow.appendChild(countHeader);
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create table body
                const tbody = document.createElement('tbody');
                layerNodes.forEach((nodeName, nodeIndex) => {
                    const row = document.createElement('tr');
                    const nodeId = data.nodes.find(n => n.name === nodeName)?.id || 0;
                    row.setAttribute('data-node-id', nodeId);
                    
                    const nameCell = document.createElement('td');
                    nameCell.textContent = nodeName;
                    const countCell = document.createElement('td');
                    countCell.textContent = formatNumber(randomInt(500, 12000));
                    
                    row.appendChild(nameCell);
                    row.appendChild(countCell);
                    tbody.appendChild(row);
                });
                table.appendChild(tbody);
                tableSection.appendChild(table);
                
                // Insert after JSON section
                jsonSection.parentNode.insertBefore(tableSection, jsonSection.nextSibling);
            });
        }
        
        // Set up event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const randomizeBtn = document.getElementById('randomize-data');
            
            if (randomizeBtn) {
                randomizeBtn.addEventListener('click', function() {
                    // Add visual feedback
                    randomizeBtn.disabled = true;
                    randomizeBtn.textContent = 'Generating...';
                    
                    setTimeout(() => {
                        // Generate completely new context and data
                        const newData = generateNewContextData();
                        
                        // Update both JSON and table data
                        updateJsonData(newData);
                        updateTableData(newData, newData.context);
                        
                        // Update button
                        randomizeBtn.disabled = false;
                        randomizeBtn.textContent = 'ðŸŽ² Generate New Context & Data';
                        
                        // Show success message
                        const message = document.createElement('div');
                        message.style.cssText = 'background: #4caf50; color: white; padding: 10px; border-radius: 4px; margin-top: 10px; text-align: center;';
                        message.textContent = `âœ… Generated ${newData.context.name}! Use "Refresh from Page" in SankeyStone.`;
                        
                        const controlsSection = randomizeBtn.parentNode;
                        controlsSection.appendChild(message);
                        
                        // Remove message after 5 seconds
                        setTimeout(() => {
                            message.remove();
                        }, 5000);
                        
                    }, 500);
                });
            }
        });
    </script>
</body>
</html>
